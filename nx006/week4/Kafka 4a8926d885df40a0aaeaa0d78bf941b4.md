# Kafka

# Introduction - Kafka를 사용하는 이유

## DBMS의 예시

![Untitled](Kafka%204a8926d885df40a0aaeaa0d78bf941b4/Untitled.png)

![Untitled](Kafka%204a8926d885df40a0aaeaa0d78bf941b4/Untitled%201.png)

MVCC에 대한 이야기를 해보겠습니다.

아무래도 여기에 모인 분들 중에서 3, 4학년의 비중이 높은 편이니, 현재 기디비를 수강하고 계시는 분들이 많을 것 같아서, 거기 수업에 나온 예시로 intro를 도입하겠습니다.

우리가 DBMS를 사용하는 이유는 여러가지가 있지만, 그 중 하나는 파일 시스템의 문제점으로부터 벗어나기 위해서라는 점이 있습니다.

파일 시스템의 문제점은 여러 프로그램이 동시에 접속하는 게 어렵다는 것에 있습니다. 예를 들어 고객 관리 앱, 주문 관리 앱이 별도로 존재한다고 할 때, 두 앱이 동시에 하나의 파일에 접속하게 되면, concurrency에 관한 문제점이 발생하게 됩니다. 또한, File에 접속하는 레이어를 앱마다 별도로 구현해야 하니깐, 레이어의 추상화가 이루어지지 않습니다.

DBMS가 도입되면서 이 문제를 해결합니다.

1. 일단 Concurrency에 대한 문제를 MVCC 모델(혹은 lock-free 모델)로 해결을 해서, 여러 앱이 동시에 한 데이터에 접근할 수 있게 구성했습니다. 그러면서 ACID라는 특징을 달성합니다.
2. 그리고 가장 중요한 특징으로, 데이터에 접근하는 레이어를 DBMS라는 하나의 추상 레이어로 분리함으로써, 여러 앱들이 데이터에 직접 접근하지 않고, DBMS라는 일반화된 레이어를 통해서 접근하게 합니다.

카프카를 사용하는 이유도 이와 비슷합니다.

## 메시징 큐/이벤트 큐를 사용하는 이유

![Untitled](Kafka%204a8926d885df40a0aaeaa0d78bf941b4/Untitled%202.png)

이러한 방식의 End-to-End(엔드포인트-엔드포인트) 연결 방식의 아키텍처가 있다고 가정해봅시다. 충분히 가능한 설계 구조이죠?

위 방식은 크게 네 가지 치명적인 문제점이 존재합니다.

1. 각 데이터 연결 라인마다, 각기 다른 방식의 파이프라인 연결이 필요합니다.
2. 확장이 매우 어렵습니다.
3. 복잡성이 매우 증가합니다.
4. 실시간 데이터 스트리밍이 어렵습니다.

카프카 등의 메시징 큐/이벤트 큐 시스템은 이러한 복잡한 데이터 파이프라인 구조를 단순화시키기 위해서 등장했습니다.

![Untitled](Kafka%204a8926d885df40a0aaeaa0d78bf941b4/Untitled%203.png)

카프카의 중요한 사용 목적 중 하나는, 데이터의 흐름을 하나의 포인트에서 통제하겠다는 의지입니다.

이러한 방식의 유용한 점은 여러 가지가 있습니다.

1. 데이터의 흐름을 관리하는 것이 쉬워집니다.
2. 데이터를 주고 받는 통일된 규격이 생깁니다.
    1. kafka가 일종의 Proxy이자, 각 Consumer/Producer에게 façade interface를 제공합니다.
3. 수평적 확장에 용이합니다.
4. 각 어플리케이션, 서버, 클라이언트들은 데이터를 어떻게 전송할 지 고민하지 않아도 됩니다. 전송될 데이터를 처리하는데 집중할 수 있습니다.

![Untitled](Kafka%204a8926d885df40a0aaeaa0d78bf941b4/Untitled%204.png)

그리고 카프카에 데이터를 집어넣는 주체를 Producer, 그리고 이 데이터를 처리하는 주체를 Consumer라고 합니다.

그리고 Producer와 Consumer가 다루는 데이터를 메시지라고 합니다.

그리고 이 메시지들은 토픽 안에 저장됩니다.

## RabbitMQ VS Kafka의 차이점

위에서 메시지 큐, 혹은 메시지 브로커를 사용하는 이유에 대해서 알아보았습니다.

그런데 Kafka를 제대로 알기 위해선, 카프카가 RabbitMQ, Redis Queue와 다른 점에 대해서 알아야 합니다.

사실 카프카를 제대로 알기 위해서는, 카프카가 메시지 큐 시스템이 아니라는 것부터 이해해야 합니다.

![Untitled](Kafka%204a8926d885df40a0aaeaa0d78bf941b4/Untitled%205.png)

RabbitMQ는 메시지 큐 방식의 메시지 브로커 시스템이 맞습니다.

Producer가 메시지를 생성해서 큐에 집어넣으면, Consumer가 메시지를 큐에서 하나씩 빼서 처리합니다.

큐니깐 FIFO 룰에 따라서 메시지가 빠져야 메시지 큐입니다.

![Untitled](Kafka%204a8926d885df40a0aaeaa0d78bf941b4/Untitled%206.png)

그런데 카프카는 조금 다르게 작동합니다. Producer가 큐와 비슷한 공간에 메시지를 생성해서 집어넣는 것은 동일한데요, 카프카에서는 이 파이프라인을 큐가 아닌 토픽이라고 합니다.

![Untitled](Kafka%204a8926d885df40a0aaeaa0d78bf941b4/Untitled%207.png)

그리고 Consumer는 이 파티션에서, 메시지를 하나씩 참조하는데, 이때 메시지가 파티션에서 사라지지 않습니다. 그대로 남아 있어요. 그래서 큐가 아닌 토픽이라는 이름을 갖고 있습니다.

그리고 카프카는 메시지 브로커라는 이름대신, ‘이벤트 브로커’에 속합니다.

이러한 이벤트 브로커의 장점은, 토픽 내 파티션에서 메시지가 사라지지 않기 때문에, 같은 메시지를 다른 Consumer Group이 또 참조할 수 있습니다.

이렇게 한 번 컨슈머 그룹이 메시지를 참조하고 나면, 참조 위치가 이동됩니다. 그래서 마치 큐처럼, 컨슈머는 파티션 내의 다음 메시지를 참조할 수 있게 됩니다.

각각의 컨슈머 그룹이 자신들의 참조 위치를 갖고 있습니다.

### 메시지의 삭제

그렇다면 큐와 다르게 카프카는 메시지가 토픽 안에 남아 있게 되는데, 언제 사라지는 것일까요?

카프카는 Consumer가 소모한다고 메시지가 사라지는 게 아니고, 메시지가 쌓이고 쌓여서 일정 용량 이상이 되었을 때 오래된 메시지를 삭제하거나, 혹은 일정 시간이 지나면 메시지를 삭제하는 구조입니다.

### 이벤트 브로커 방식의 장점

메시지 브로커 방식과 다르게 이벤트 방식의 장점이 몇 가지 있습니다.

- 성능적인 장점
    - 카프카는 토픽에 메시지가 쌓여도 성능이 저하되지 않습니다.
    - 그에 반해서 메시지 브로커 방식은, 메시지 큐 안에 메시지가 쌓이면, 성능이 크게 저하된다고 합니다.
- 한 개의 메시지를 여러 컨슈머가 소비할 수 있다
    - 큐에서 메시지가 사라지는 구조가 아니기 때문에, 다른 컨슈머 그룹이 이미 사용된 메시지를 다시 한 번 가져가서 사용할 수 있습니다.
- 이벤트 브로커는 메시지 브로커의 역할을 수행할 수 있지만, 메시지 브로커는 이벤트 브로커 방식을 수행할 수 없다
    - 카프카는 메시지 큐 방식의 AMQP와 함께, STOMP, HTTP, MQTT 등의 프로토콜을 지원한다
    - 그러나 RabbitMQ는 대부분 AMQP라는 한정된 프로토콜을 지원한다.

### 이벤트 브로커 방식의 단점

하지만 이벤트 브로커 방식의 단점도 있습니다. 정확히는 카프카의 단점인데, 지나치게 복잡합니다. 그래서 러닝 커브가 매우 높습니다.

그리고 일단, 카프카 클러스터를 유지하기 위해서, Zookeeper라는 별도의 클러스터링 도구를 사용해야 합니다. 카프카를 사용하기 위해서 주키퍼라는 외부 소프트웨어를 반드시 사용해야 하니, 더욱더 러닝 커브가 올라가게 됩니다.

![Untitled](Kafka%204a8926d885df40a0aaeaa0d78bf941b4/Untitled%208.png)

주키퍼는 도커 컨테이너로 따지면, k8s와 비슷한 역할을 합니다.

도커에서는 도커 스웜이 있듯이, 카프카에서도 자체적인 클러스터 관리 도구를 만든다고 하는데, 아직까지는 주키퍼를 사용해야 합니다.

또한 MQ와 다르게, 카프카는 파티션 별로 들어간 메시지의 순서가 보장되지 않습니다. 그래서 들어간 순서가 중요한 메시지를 다룰 때에는, 이 문제를 따로 고민해야 합니다.

# Kafka를 알아보자

위에서는 카프카를 사용하는 이유에 대해서 알아보았으니깐, 이번에는 카프카에 대해서 더 자세히 알아보겠습니다.

![Untitled](Kafka%204a8926d885df40a0aaeaa0d78bf941b4/Untitled%209.png)

카프카의 논리적 구조는 위와 같습니다.

## Producer

프로듀서는 카프카의 파티션에 메시지를 집어넣습니다.

## Consumer

컨슈머는 각 메시지를 처리합니다.

컨슈머는 동일한 역할을 수행하는 컨슈머들끼리 컨슈머 그룹을 지을 수 있습니다. 컨슈머 그룹은 한 파티션을 구독해서, 메시지를 읽어들일 수 있습니다.

## Topic

토픽은 메시지가 저장되는 논리적인 저장소입니다. 이 토픽은 여러 개의 파티션으로 나뉠 수 있습니다.

## Partition

파티션은 같은 토픽 내에서 메시지를 세분화해서 분산 저장하는 하위 단위입니다.

## Broker

![Untitled](Kafka%204a8926d885df40a0aaeaa0d78bf941b4/Untitled%2010.png)

위의 사진은 카프카의 물리적인 구조입니다.

카프카 클러스터는 일반적으로 여러 개의 브로커로 구성이 됩니다. 이 브로커는 물리적인 카프카 서버 인스턴스입니다.

각 브로커는 여러 토픽의 파티션들을 분리해서 저장할 수 있습니다.

## 주키퍼

주키퍼는 카프카의 브로커와 컨슈머를 관리하는 클러스터링 도구입니다. 카프카는 주키퍼 없이 돌아가지 않습니다.

주키퍼는 다음 역할을 수행합니다.

- 컨트롤러 선정: 컨트롤러는 파티션 관리를 책임지는 브로커 중 하나입니다. 여기서 파티션 관리라 함은 리더 선정, 토픽 생성, 파티션 생성, 복제본 관리 등을 포함합니다. 하나의 노드 또는 서버가 꺼지게 된다면, 카프카 컨트롤러가 팔로워 중에서 파티션 리더를 선정합니다.
- 브로커 메타데이터: 브로커의 상태 정보 기록
- 토픽 메타 데이터 기록
- 클라이언트 할당 정보
- 카프카 토픽 ACLs: 접근 제어 목록(Access Control Lists)를 관리한다. 즉 토픽의 읽기 쓰기 권한을 결정한다.